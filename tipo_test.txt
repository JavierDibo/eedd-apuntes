# Preguntas tipo test por temas

---

## Tema 3

1 [V] La siguiente declaraci√≥n: int** p permite crear las siguientes estructuras de datos en memoria:
	se crea:
		- un puntero simple a simple (**p = 1)
			p = new int*;
			*p = new int;
		- un array de punteros (*p[i] = 1)
			p = new int*[]
			for(): p[i] = new int;
		- un array a un array (p[i][j] = 1)
			p = new int*[]
			for(): p = new int[]

2 [V] Si la declaraci√≥n del puntero anterior p se realiza como se muestra a continuaci√≥n entonces p es creado como
una variable residente en la pila de aplicaci√≥n:

	void f() {
		int **p;
		...
	}

Las declaraciones autom√°ticas se realizan en la pila.

3 [V] Una matriz declarada como int a[3][5] se almacena en una zona contigua de memoria

Las matrices son reservadas al mismo tiempo en zonas contiguas.

4 [V] Sea m1 una matriz declarada como int m1[10][20] y m2 un puntero declarado como int **m2 e iniciado
mediante el siguiente c√≥digo:

	m2 = new int*[10];
	for (int c = 0; c < 10; ++c) {
		m2[c] = new int[20];
	}

Entonces el elemento existente en la posici√≥n (3, 7) se accede de igual manera con ambas estructuras de datos:
m1[3][7] / m2[3][7].

Verdadero, las dos declaraciones son equivalentes, por lo tanto, su forma de acceso tambi√©n.

5. [V] El siguiente c√≥digo presenta memory leaks:

	int *p = new int[1000];
		for (int c = 0; c <= 1000; ++c) {
		p[c] = 0;
	}

Verdadero. Si se asume que este es todo el c√≥digo, entonces no se libera la memoria y por lo tanto existe un memory leak.
	Ademas se presenta un heap overflow ( c <= 1000 ).

6 [F] El siguiente c√≥digo presenta heap overflows:
	
	int *p;
	for (int c = 0; c < 10; ++c) {
		p = new int[100];
	}

Falso. No se esta intentando acceder a memoria sin reservar.  Lo que esta ocurriendo es un memory leak. No se est√° usando delete[].

7 [V] Una plantilla de clase instanciable para el tipo T = int puede que no lo sea para el tipo T = MiClase, es
decir, que una plantilla puede no aceptar cualquier tipo como par√°metro.

Verdadero. Si la clase es muy distinta en sus operadores, por ejemplo una clase Matriz, la platilla no funcionar√≠a correctamente.

8 [V] A trav√©s el puntero int **m podemos manejar una matriz creada en memoria din√°mica con un n√∫mero de filas
y columnas arbitrario.

Verdadero. Se puede declarar una matriz de cualquier tama√±o usando memoria din√°mica (new) con el c√≥digo:

	m = new int*[p]
	for (int i=0; i<p; i++)
		m[i] = new int[q]
		
---		

## Tema 4

1 [V] Un vector din√°mico es una estructura de datos b√°sica que puede ser utilizada en la implementaci√≥n de
asociaciones y composiciones m√∫ltiples cuando no hay restricciones o necesidades especiales en las mismas.

Verdadero. Es una estructura vers√°til que puede usarse para la mayor√≠a de relaciones entre clases debido a su 
  insercion en O(1) al final.

2 [F] Un dato almacenado en un vector din√°mico que permanece en dicha estructura de datos a lo largo de todo su
ciclo de vida nunca cambia su posici√≥n de memoria.

Falso. Se puede dar que el mismo dado cambie de array y por tanto de posisic√≥n de memoria cuando el vector 
  disminuye/aumenta de tama√±o en el paradigma de vectores din√°micos estudiado.

3 [V] La siguiente definici√≥n de vector est√°tico necesita de constructor copia y operador de asignaci√≥n:

	template<typename T> class MiVect{
			int tama;
			T *v;
		public:
			MiVect(int n){ 
				tama = n;
				v = new T[tama]; 
			}
		...
	};

Verdadero. Toda estructura de datos completa necestia un vector de asignaci√≥n y copia para poder hacer uso 
de los recursos dinamicos automaticso de C++.


4 [F] La misma clase anterior debe definir as√≠ el operador corchete ‚Äú[ ]‚Äù para que funcione correctamente (se obvian
las comprobaciones de rango):

	T operator[](unsigned i) { 
		return v[i]; 
	}

Falso. El operador corchete debe devolver una referencia al objeto, no una copia.
	
5 [F] Si se ha instanciado en la clase Biblioteca a Mivect para implementar una relaci√≥n de asociaci√≥n con la clase
Libro como:

	MiVect<Libro*> estante;
	
Entonces el destructor de Biblioteca debe entonces eliminar estante ejecutando:
	
	delete[] estante;

Falso. La asociaci√≥n implica utilizar objetos ya existentes con un ciclo de vida independiente. La clase Biblioteca no
tiene que eliminar a estante.

7 [V] Es posible eliminar una posici√≥n de un vector din√°mico en tiempo O(1) si no es necesario preservar el orden
de los datos.

Verdadero. Se intercambia el valor del objeto final con el objeto en la posici√≥n a eliminar en O(1).

8 [F] La implementaci√≥n normal de un vector din√°mico implementa una reducci√≥n del tama√±o f√≠sico tamf a la mitad
cuando el tama√±o l√≥gico taml cae por debajo de tamf/2.

Falso. Esta reducci√≥n sucede cuando el tama√±o l√≥gico es 1/3 del tama√±o f√≠sico.

---

## Tema 5

1 [V] El operador de asignaci√≥n de la clase Matriz<T>::operator= debe siempre destruir la matriz destino de la
asignaci√≥n.

Verdadero. La implementacion implica eliminar la primera matriz, pues la matriz a asignar puede tener unas dimensiones distintas.

SIEMPRE???

2 [F] El operador de la clase Matriz<T>::operator+= devuelve el objeto resultado por copia.

Falso. Estos operadores devuelven una referencia al objeto.

3 [F] La implementaci√≥n de conjuntos mediante vectores realiza la intersecci√≥n en tiempo lineal.

Falso. La intersecci√≥n se realiza comprobando la existencia de cada numero en A dentro de B, es decir, O(n^2).

4 [V] El problema que poseen los conjuntos de bits es que el ID de un elemento debe ser un entero desde 0 hasta el
tama√±o del conjunto -1. Para convertirlo en un ID gen√©rico se necesita otra EEDD.

Verdadero. Los objetos est√°n codificados en numeros enteros, donde n/8 se refiere a su byte, y n%8 a su bit.
Cada conjunto debe recibir nombres con valores num√©ricos enteros. Se tiene que usar otra EEDD, como un par, para asociar una etiqueta.

5 [F] Para almacenar 3841 datos en un conjunto de bits, debo crear un buffer de 480 bytes.

Falso. 480*8 = 3841, necesitamos un byte extra para almacenar el siguiente bit (dato).

6 [F] a.intersec(b+a) == a es correcto

Falso??. 
	- intersec se usa as√≠.
	- b+a deberia devolver un objeto correcto.
	- operator== no est√° definido en la presentaciones...

7 [F] El resultado de realizar esta operaci√≥n: char mascara = 1 << (500 % 8); es 00000100.

Falso. El operador << mueve un bit la cantidad de pasos indicados a la izquierda, es decir 4 (500%8) pasos.
El resultado ser√≠a: 00010000

---

## Tema 6

1 [V] El tiempo para eliminar un dato en una posici√≥n arbitraria de una lista es lineal.

Verdadero. Para borrar un dato tienes que llegar al dato recorriendo toda la lista.

2 [V] El tiempo para eliminar un dato en una posici√≥n apuntada por un iterador es lineal.

Verdadero. Para borrar un dato que no est√© ni al inicio ni al final,
tienes que recorrer la lista con el iterador hasta llegar a ella.

3 [V] Para eliminar e insertar un dato en posiciones intermedias de una lista se necesita un puntero a la posici√≥n
anterior al dato que se va a insertar/borrar.

Verdadero. Es necesario pues hay que asignar al nodo anterior que el nodo nuevo es su nodo siguiente.

4 [V] Se puede realizar la operaci√≥n merge_sort entre dos listas ordenadas en tiempo O(n+m), siendo n y m los
tama√±os respectivos de ambas listas.

Verdadero. Se tienen que comparar los datos una sola vez al insertarlos.

5 [F] Un dato que permanece en una lista cambia su posici√≥n a veces al sufrir la lista inserciones y borrados.

Falso. A menos que el dato sea manipulado directamente, su posici√≥n en memoria no cambia nunca.

---

## Tema 7

1 [F] Una lista doblemente enlazada permite realizar busquedas binarias en tiempo O(log n) si los datos se encuentran
ordenados.

Falso. Para llegar al valor central tiene que recorrer la lista. Ser√≠a O(n).

2 [F] Iterar sobre un vector din√°mico es siempre m√°s r√°pido que sobre una lista enlazada (simple o doble).

Falso. Iterar sobre un vector dinamico consiste en rastrear memoria contigua.
En una lista debes hacer saltos en memoria a traves de punteros, es m√°s lento.

3 [F] El siguiente c√≥digo inserta correctamente en un caso gen√©rico (lista con datos), un nuevo nodo apuntado por
p por delante de la posici√≥n del nodo apuntado por q en una lista doblemente enlazada y circular.

	p->siguiente = q;
	p->anterior = q->anterior;
	q->anterior = p;
	p->anterior->siguiente = q;

Falso. La ultima linea deber√≠a ser: "p->anterior->siguiente = P;".

4 [V] Transferir todos los nodos de una lista doblemente enlazada lista1 al final de la lista doblemente enlazada lista2
requiere tiempo O(1) (nota: lista1 queda vac√≠a tras esta operaci√≥n).

Verdadero. Una lista se compone de dos punteros. Si se toma como cabecera y cola los nodos #1 y #n de lista1 en lista2,
y se ponen cabecera y cola de lista1 a nullptr, de forma efectiva la lista2 contiene todos los nodos y lista1 queda vac√≠a.

5 [F] La siguiente implementaci√≥n del constructor copia de una lista enlazada no contiene errores:

	ListaEnlazada<T>::ListaEnlazada(const ListaEnlazada<T> &lista) {
	
		cabecera = lista.cabecera;
		cola = lista.cola;
	}
	
Falso. S√≠ contiene errores. En este caso se est√° renombrando la lista, en lugar de hacer una copia completa.
Si se eliminiase la lista original, la lista copiada no deber√≠a de desaparecer como en este caso.

6 [V] La implementaci√≥n de las matrices dispersas es completamente distinta de las matrices ordinarias, estando
basada en el uso de listas enlazadas.

Verdadero. Las matrices dispersas se implementan mediante listas para evitar el uso ineficiente de memoria.

---

## Tema 8

1 [F] El contenedor list<T> de STL implementa el operador [] para acceder directamente al dato almacenado en una posici√≥n
arbitraria.

Falso. list se tiene que usar mediante iteradores.

2 [V] Se ha pensado en implementar una matriz para almacenar todos los jugadores convocados en todos los partidos de todas
las jornadas de la liga de f√∫tbol. Esta ser√≠a una posible estructura de datos para crear dicha tabla: 

	vector<vector<vector<Jugador> > > jugadores.

Verdadero. Estas declarando una estructura en 3D. Si bien no es una matriz, es una estructura factible.

3 [F] Para simular una lista circular (p.e. procesos de un S.O) en el que los datos entran siempre por el mismo lugar pero
salen en cualquier momento es igualmente eficiente utilizar una lista (list) que un vector de STL.

Falso. Los vectores tienen mala eficiencia al eliminar/insertar por delante, ser√≠a m√°s √∫til una lista para el caso expuesto.

4 [V] Se ha utilizado la siguiente estructura de datos para implementar un editor de texto interactivo: 

	list<vector<char>> texto. 

La implementaci√≥n de la operaci√≥n pulsarTecla(char c) ser√≠a la siguiente: 

	i->insert(i->begin() + pos, c)

siendo i un iterador de la lista que apunta a la l√≠nea donde se encuentra el cursor y pos un entero positivo que
indica la posici√≥n del cursor en dicha l√≠nea.

Veradero. Se accede al vector dentro de i (de lista) obtenemos un vector "miVector"
Usamos insert(0 + pos, c) en el vector, es decir, insertamos c en la posicion pos del vector.


5 [F] Sean dos conjuntos a y b de palabras, implementados usando dos vectores de STL instanciados al tipo string.
Entonces obtener el vector c = a ‚à© b (palabras que est√°n en ambos conjuntos) requiere un tiempo cuadr√°tico.

Falso. Si se ordenan los vectores se puede hacer una busqueda lineal O(n) para comparar los objetos.

Aunque si los vectores son aleatorios ser√≠a cuadr√°tica O(n^2).

6 [F] La inserci√≥n de un dato d al principio de un vector v de STL mediante v.insert(v.begin(), d) requiere tiempoF
O(1).

Los vectores en STL no presentan insercion en O(1) al principio. Para esto se deber√≠a usar un deque.