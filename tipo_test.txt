# Preguntas tipo test por temas

---

## Tema 3

1 [V] La siguiente declaraci√≥n: int** p permite crear las siguientes estructuras de datos en memoria:
	se crea:
		- un puntero simple a simple (**p = 1)
			p = new int*;
			*p = new int;
		- un array de punteros (*p[i] = 1)
			p = new int*[]
			for(): p[i] = new int;
		- un array a un array (p[i][j] = 1)
			p = new int*[]
			for(): p = new int[]

2 [V] Si la declaraci√≥n del puntero anterior p se realiza como se muestra a continuaci√≥n entonces p es creado como
una variable residente en la pila de aplicaci√≥n:

	void f() {
		int **p;
		...
	}

Las declaraciones autom√°ticas se realizan en la pila.

3 [V] Una matriz declarada como int a[3][5] se almacena en una zona contigua de memoria

Las matrices son reservadas al mismo tiempo en zonas contiguas.

4 [V] Sea m1 una matriz declarada como int m1[10][20] y m2 un puntero declarado como int **m2 e iniciado
mediante el siguiente c√≥digo:

	m2 = new int*[10];
	for (int c = 0; c < 10; ++c) {
		m2[c] = new int[20];
	}

Entonces el elemento existente en la posici√≥n (3, 7) se accede de igual manera con ambas estructuras de datos:
m1[3][7] / m2[3][7].

Verdadero, las dos declaraciones son equivalentes, por lo tanto, su forma de acceso tambi√©n.

5. [V] El siguiente c√≥digo presenta memory leaks:

	int *p = new int[1000];
		for (int c = 0; c <= 1000; ++c) {
		p[c] = 0;
	}

Verdadero. Si se asume que este es todo el c√≥digo, entonces no se libera la memoria y por lo tanto existe un memory leak.
	Ademas se presenta un heap overflow ( c <= 1000 ).

6 [F] El siguiente c√≥digo presenta heap overflows:
	
	int *p;
	for (int c = 0; c < 10; ++c) {
		p = new int[100];
	}

Falso. No se esta intentando acceder a memoria sin reservar.  Lo que esta ocurriendo es un memory leak. No se est√° usando delete[].

7 [V] Una plantilla de clase instanciable para el tipo T = int puede que no lo sea para el tipo T = MiClase, es
decir, que una plantilla puede no aceptar cualquier tipo como par√°metro.

Verdadero. Si la clase es muy distinta en sus operadores, por ejemplo una clase Matriz, la platilla no funcionar√≠a correctamente.

8 [V] A trav√©s el puntero int **m podemos manejar una matriz creada en memoria din√°mica con un n√∫mero de filas
y columnas arbitrario.

Verdadero. Se puede declarar una matriz de cualquier tama√±o usando memoria din√°mica (new) con el c√≥digo:

	m = new int*[p]
	for (int i=0; i<p; i++)
		m[i] = new int[q]
		
---		

## Tema 4

1 [V] Un vector din√°mico es una estructura de datos b√°sica que puede ser utilizada en la implementaci√≥n de
asociaciones y composiciones m√∫ltiples cuando no hay restricciones o necesidades especiales en las mismas.

Verdadero. Es una estructura vers√°til que puede usarse para la mayor√≠a de relaciones entre clases debido a su 
  insercion en O(1) al final.

2 [F] Un dato almacenado en un vector din√°mico que permanece en dicha estructura de datos a lo largo de todo su
ciclo de vida nunca cambia su posici√≥n de memoria.

Falso. Se puede dar que el mismo dado cambie de array y por tanto de posisic√≥n de memoria cuando el vector 
  disminuye/aumenta de tama√±o en el paradigma de vectores din√°micos estudiado.

3 [V] La siguiente definici√≥n de vector est√°tico necesita de constructor copia y operador de asignaci√≥n:

	template<typename T> class MiVect{
			int tama;
			T *v;
		public:
			MiVect(int n){ 
				tama = n;
				v = new T[tama]; 
			}
		...
	};

Verdadero. Toda estructura de datos completa necestia un vector de asignaci√≥n y copia para poder hacer uso 
de los recursos dinamicos automaticso de C++.


4 [F] La misma clase anterior debe definir as√≠ el operador corchete ‚Äú[ ]‚Äù para que funcione correctamente (se obvian
las comprobaciones de rango):

	T operator[](unsigned i) { 
		return v[i]; 
	}

Falso. El operador corchete debe devolver una referencia al objeto, no una copia.
	
5 [F] Si se ha instanciado en la clase Biblioteca a Mivect para implementar una relaci√≥n de asociaci√≥n con la clase
Libro como:

	MiVect<Libro*> estante;
	
Entonces el destructor de Biblioteca debe entonces eliminar estante ejecutando:
	
	delete[] estante;

Falso. La asociaci√≥n implica utilizar objetos ya existentes con un ciclo de vida independiente. La clase Biblioteca no
tiene que eliminar a estante.

7 [V] Es posible eliminar una posici√≥n de un vector din√°mico en tiempo O(1) si no es necesario preservar el orden
de los datos.

Verdadero. Se intercambia el valor del objeto final con el objeto en la posici√≥n a eliminar en O(1).

8 [F] La implementaci√≥n normal de un vector din√°mico implementa una reducci√≥n del tama√±o f√≠sico tamf a la mitad
cuando el tama√±o l√≥gico taml cae por debajo de tamf/2.

Falso. Esta reducci√≥n sucede cuando el tama√±o l√≥gico es 1/3 del tama√±o f√≠sico.

---

## Tema 5

1 [V] El operador de asignaci√≥n de la clase Matriz<T>::operator= debe siempre destruir la matriz destino de la
asignaci√≥n.

Verdadero. La implementacion implica eliminar la primera matriz, pues la matriz a asignar puede tener unas dimensiones distintas.

SIEMPRE???

2 [F] El operador de la clase Matriz<T>::operator+= devuelve el objeto resultado por copia.

Falso. Estos operadores devuelven una referencia al objeto.

3 [F] La implementaci√≥n de conjuntos mediante vectores realiza la intersecci√≥n en tiempo lineal.

Falso. La intersecci√≥n se realiza comprobando la existencia de cada numero en A dentro de B, es decir, O(n^2).

4 [V] El problema que poseen los conjuntos de bits es que el ID de un elemento debe ser un entero desde 0 hasta el
tama√±o del conjunto -1. Para convertirlo en un ID gen√©rico se necesita otra EEDD.

Verdadero. Los objetos est√°n codificados en numeros enteros, donde n/8 se refiere a su byte, y n%8 a su bit.
Cada conjunto debe recibir nombres con valores num√©ricos enteros. Se tiene que usar otra EEDD, como un par, para asociar una etiqueta.

5 [F] Para almacenar 3841 datos en un conjunto de bits, debo crear un buffer de 480 bytes.

Falso. 480*8 = 3841, necesitamos un byte extra para almacenar el siguiente bit (dato).

6 [F] a.intersec(b+a) == a es correcto

Falso??. 
	- intersec se usa as√≠.
	- b+a deberia devolver un objeto correcto.
	- operator== no est√° definido en la presentaciones...

7 [F] El resultado de realizar esta operaci√≥n: char mascara = 1 << (500 % 8); es 00000100.

Falso. El operador << mueve un bit la cantidad de pasos indicados a la izquierda, es decir 4 (500%8) pasos.
El resultado ser√≠a: 00010000

---

## Tema 6

1 [V] El tiempo para eliminar un dato en una posici√≥n arbitraria de una lista es lineal.

Verdadero. Para borrar un dato tienes que llegar al dato recorriendo toda la lista.

2 [V] El tiempo para eliminar un dato en una posici√≥n apuntada por un iterador es lineal.

Verdadero. Para borrar un dato que no est√© ni al inicio ni al final,
tienes que recorrer la lista con el iterador hasta llegar a ella.

3 [V] Para eliminar e insertar un dato en posiciones intermedias de una lista se necesita un puntero a la posici√≥n
anterior al dato que se va a insertar/borrar.

Verdadero. Es necesario pues hay que asignar al nodo anterior que el nodo nuevo es su nodo siguiente.

4 [V] Se puede realizar la operaci√≥n merge_sort entre dos listas ordenadas en tiempo O(n+m), siendo n y m los
tama√±os respectivos de ambas listas.

Verdadero. Se tienen que comparar los datos una sola vez al insertarlos.

5 [F] Un dato que permanece en una lista cambia su posici√≥n a veces al sufrir la lista inserciones y borrados.

Falso. A menos que el dato sea manipulado directamente, su posici√≥n en memoria no cambia nunca.

---

## Tema 7

1 [F] Una lista doblemente enlazada permite realizar busquedas binarias en tiempo O(log n) si los datos se encuentran
ordenados.

Falso. Para llegar al valor central tiene que recorrer la lista. Ser√≠a O(n).

2 [F] Iterar sobre un vector din√°mico es siempre m√°s r√°pido que sobre una lista enlazada (simple o doble).

Falso. Iterar sobre un vector dinamico consiste en rastrear memoria contigua.
En una lista debes hacer saltos en memoria a traves de punteros, es m√°s lento.

3 [F] El siguiente c√≥digo inserta correctamente en un caso gen√©rico (lista con datos), un nuevo nodo apuntado por
p por delante de la posici√≥n del nodo apuntado por q en una lista doblemente enlazada y circular.

	p->siguiente = q;
	p->anterior = q->anterior;
	q->anterior = p;
	p->anterior->siguiente = q;

Falso. La ultima linea deber√≠a ser: "p->anterior->siguiente = P;".

4 [V] Transferir todos los nodos de una lista doblemente enlazada lista1 al final de la lista doblemente enlazada lista2
requiere tiempo O(1) (nota: lista1 queda vac√≠a tras esta operaci√≥n).

Verdadero. Una lista se compone de dos punteros. Si se toma como cabecera y cola los nodos #1 y #n de lista1 en lista2,
y se ponen cabecera y cola de lista1 a nullptr, de forma efectiva la lista2 contiene todos los nodos y lista1 queda vac√≠a.

5 [F] La siguiente implementaci√≥n del constructor copia de una lista enlazada no contiene errores:

	ListaEnlazada<T>::ListaEnlazada(const ListaEnlazada<T> &lista) {
	
		cabecera = lista.cabecera;
		cola = lista.cola;
	}
	
Falso. S√≠ contiene errores. En este caso se est√° renombrando la lista, en lugar de hacer una copia completa.
Si se eliminiase la lista original, la lista copiada no deber√≠a de desaparecer como en este caso.

6 [V] La implementaci√≥n de las matrices dispersas es completamente distinta de las matrices ordinarias, estando
basada en el uso de listas enlazadas.

Verdadero. Las matrices dispersas se implementan mediante listas para evitar el uso ineficiente de memoria.

---

## Tema 8

1 [F] El contenedor list<T> de STL implementa el operador [] para acceder directamente al dato almacenado en una posici√≥n
arbitraria.

Falso. list se tiene que usar mediante iteradores.

2 [V] Se ha pensado en implementar una matriz para almacenar todos los jugadores convocados en todos los partidos de todas
las jornadas de la liga de f√∫tbol. Esta ser√≠a una posible estructura de datos para crear dicha tabla: 

	vector<vector<vector<Jugador> > > jugadores.

Verdadero. Estas declarando una estructura en 3D. Si bien no es una matriz, es una estructura factible.

3 [F] Para simular una lista circular (p.e. procesos de un S.O) en el que los datos entran siempre por el mismo lugar pero
salen en cualquier momento es igualmente eficiente utilizar una lista (list) que un vector de STL.

Falso. Los vectores tienen mala eficiencia al eliminar/insertar por delante, ser√≠a m√°s √∫til una lista para el caso expuesto.

4 [V] Se ha utilizado la siguiente estructura de datos para implementar un editor de texto interactivo: 

	list<vector<char>> texto. 

La implementaci√≥n de la operaci√≥n pulsarTecla(char c) ser√≠a la siguiente: 

	i->insert(i->begin() + pos, c)

siendo i un iterador de la lista que apunta a la l√≠nea donde se encuentra el cursor y pos un entero positivo que
indica la posici√≥n del cursor en dicha l√≠nea.

Veradero. Se accede al vector dentro de i (de lista) obtenemos un vector "miVector"
Usamos insert(0 + pos, c) en el vector, es decir, insertamos c en la posicion pos del vector.


5 [F] Sean dos conjuntos a y b de palabras, implementados usando dos vectores de STL instanciados al tipo string.
Entonces obtener el vector c = a ‚à© b (palabras que est√°n en ambos conjuntos) requiere un tiempo cuadr√°tico.

Falso. Si se ordenan los vectores se puede hacer una busqueda lineal O(n) para comparar los objetos.

Aunque si los vectores son aleatorios ser√≠a cuadr√°tica O(n^2).

6 [F] La inserci√≥n de un dato d al principio de un vector v de STL mediante v.insert(v.begin(), d) requiere tiempoF
O(1).

Los vectores en STL no presentan insercion en O(1) al principio. Para esto se deber√≠a usar un deque.

---

## Tema 9

1 [V] Un vector est√°tico puede implementar eficientemente a pilas y colas est√°ticas.

Verdadero. Se puede implementar una pila mediante un vector de forma trivial.
Se puede implementar una cola de tama√±o fijo con un vector usando un paradigma de vector circular.

2 [V] Una lista simplemente enlazada puede implementar eficientemente a pilas y colas din√°micas.

Verdadero. Una pila se puede implementar de haciendo push() mediante un insertarIncio. Y el pop() mediante un borrarInicio().
Una cola se puede implementar haciendo push() mediante un insertarFinal(), y un pop() mediante borrarInicio().

3 [V] Una deque puede implementar eficientemente a pilas y colas din√°micas.

Verdadero. La implementaci√≥n de pila se hace con un deque de forma estandar.
La implementaci√≥n de una cola din√°mica se puede tamb√≠en realizar con un deque.

4 [V] Se usa una pila para resolver aquellos procesos recursivos que agotan la pila.

Verdadero. Se puede usar una pila para eliminar la recursividad.

5 [F] Una cola con prioridad siempre tendr√° un push() en O(1) independientemente de la implementaci√≥n concreta (vectores,
vector de listas o listas de listas)

Falso. Para hacer una insercion en una lista se tiene que hacer una insercion ordenada O(n).

6 [F] Una stack o una queue se implementa por defecto sobre un std:list pero se puede cambiar en ambos casos el
contenedor.

Falso. Ambos se implementan de forma estand√°r mediante un deque. Aunque se puede instanciar a un list.

7 [V] Para hacer que una priority_queue de STL considere como dato m√°s prioritario al mayor, se debe definir con
el operator greater

Verdadero. EL greater asigna m√°s prioridad a los valores mayores.

8 [F] Necesito una pila para eliminar la recursividad de la sucesi√≥n de Fibonacci (Ejercicio 1)

Falso. Se puede usar una estrategia de programaci√≥n din√°mica mediante un vector.
Pero esto te lo ense√±an el algoritmos, no EEDD...

---

## Tema 12

1 [V] Implementar un heap mediante nodos y punteros al igual que el resto de √°rboles binarios tiene dos graves
inconvenientes: consume mucha m√°s memoria y la inserci√≥n en la siguiente posici√≥n libre del √∫ltimo nivel (durante
los push) o el borrado de la √∫ltima posici√≥n del √∫ltimo nivel (durante los pop) no podr√≠a implementarse en tiempo
constante.

Verdadero. Esta operacion deber√≠a realizar una busqueda lineal o logaritmica en el mejor de los casos.

2 [V] La operaci√≥n pop() es m√°s eficiente en un heap que en una cola con prioridad montada mediante una lista de
listas.

Verdadero. pop() es O(log n) en un heap, mientras que pop() en una lista de listas es O(n)

3 [F] La siguiente tabla referente a la eficiencia de las distintas implementaciones de una cola con prioridad es
correcta (n es el n√∫mero de datos y p el n√∫mero de valores de prioridad distintos):

	| Implementaci√≥n   | Push    | Pop     |
	|------------------|---------|---------|
	| Vector de listas | O(1)    | O(p)    |
	| Lista de listas  | O(p)    | O(1)    |
	| Heap             | O(log n)| O(log n)|
	
Falso. En un vector de listas, un push es O(n).

4 [V] Un heap permite obtener el dato con menor prioridad en O(1).

Falso. Permite obtener el dato con MAYOR prioridad.

5 [F] Un heap es un √°rbol binario equilibrado en altura.

Falso. Eso es un AVL. Un heap es una arbol binario completo que cumple que cada nodo padre tiene >= prioridad que sus hijos

6 [F] La uni√≥n de dos conjuntos disjuntos de tama√±os n y m puede llevarse a cabo mediante una operaci√≥n en O(1)

Falso. Si bien puede existir el caso de que sean n=1 y m=1, la notacion de O grande implica el peor caso,
es decir, si fuese n y m muy grande seria O(n)

7 [V] La operaci√≥n busca() en conjuntos disjuntos es O(n) y ‚Ñ¶(1)

Verdadero. Para la implementacion mediante arboles el peor caso es un arbol con un solo nodo hijo por nodo.
El mejor caso seria que no tenga padre.

Aunque en el caso de la implementacion mediante vectores, es siempre O(1)

---

## Tema 13

1 [V] Si la clase ClassA tiene el siguiente atributo: 

	map<string, *ClassB> miMapa; 
	
entonces necesariamente la relaci√≥n entre ClassA y ClassB es de asociaci√≥n.

Verdadero. Pues al ser punteros a objetos ya existentes, se asume que su ciclo de vida es independiente de ClassA.

2 [F] Si esta sentencia es v√°lida:

	int nuevoValor = 7;
	it = micontainer.find(clave);
	(*it).second[i] = &nuevoValor;
	
Entonces micontainer puede tener esta definici√≥n: 

	map <int, vector<int> >micontainer;
	
Falso, el vector subyacente deber√≠a tener el tipo *int. Ya que se le est√° asignando un 

3[F] El objecto mc se define como: 

	map <int, miClase> mc; 

¬øse podr√≠a realizar la siguiente operaci√≥n sobre mc?
	
	map<int, miClase>::iterator it = mc. begin(); 
	*(it).first = 5;
	
Falso. No se puede realizar un cambio de clave a un dato dentro de un mapa.

4 [V] El contenedor de STL m√°s adecuado para albergar las reservas de un restaurante para tener 
acceso a √©stas por fecha es un mapa de la siguiente forma: 

	multimap <Fecha, Reserva>
	
Verdadero. Pues con un multimapa se pueden repetir claves (Fecha) ya que hay varias 
mas de una reserva por d√≠a.

5 [F] La correspondiente definici√≥n de una matriz dispersa en STL seg√∫n la Lecci√≥n 7 es: 

	vector <list <int> > matrizDis;
	
Falso. Seg√∫n la lecci√≥n 7 la matriz dispersa se define como una lista de listas.
	
6 [F] La siguiente sentencia: 

v["Mar√≠a"] = dato; 

es v√°lida si v representa a un deque.

Falso. Si se intentase acceder a operador[] de un deque se devolver√≠a mem["Maria"], esto no es un √≠ndice v√°lido.
Este tipo de asignaci√≥n ser√≠a correcta para un mapa donde la clave sea un string.

7 [V] Un map definido como: map<int, ClaseA> puede sustituirse por un set<ClaseA> si ClaseA tiene sobrecargado el
operator< y la clave entera forma parte de la clase ClaseA.

Verdadero. Si la clave forma parte de la clase A, se puede utilizar un set ya que hay un operator< definido.

8 [V] Si en el caso anterior el operator< ya est√° us√°ndose para otro tipo de ordenaci√≥n sobre ClaseA, entonces
se puede usar la definici√≥n: 

	set<ClaseA, comparaClaseA>

siendo comparaClaseA una clase de comparaci√≥n para ClaseA.

Verdadero. En este caso se dejaria de usar la operacion por defecto less<T>
y se optaria por el operator() de la clase comparadora

## Tema 14

1 [F] Toda funci√≥n de dispersi√≥n debe acabar con %tamaTabla

Falso. Hay algunas funciones de dispersi√≥n (como la funci√≥n de dispersi√≥n de cadenas) que no lo necesita.

2 [F] El djb2 no es una funci√≥n de dispersi√≥n de cadenas

Falso. EL djb2 es una funci√≥n de dispersi√≥n de cadenas.

3[F] Si la tabla A tiene un lambda Œª = 0.5 y en la tabla B, Œª= 0.75, entonces la tabla B tiene m√°s datos que la A.

Falso. El factor de carga (Œª) no indica lo llena que est√° la tabla, pero no la cantidad de datos que almacena.

4 [V] Si la tabla A tiene un lambda Œª = 0.5 y en la tabla B, Œª= 0.75, entonces la tabla B est√° porcentualmente m√°s llena
que la A.

Verdadero. El factor de carga nos indica que B est√° un 75% llena, mientras que A est√° un 50% llena, es decir, B esat√° mas llena porcentualmente.

5 [F] En STL la dispersi√≥n abierta se define como un list< list <Entrada <T> > >

Falso. Se define mediante un vector de listas.

6 [F] En dispersi√≥n abierta se sabe que la funci√≥n de dispersi√≥n es buena conociendo el tama√±o de las listas de
entradas.

Falso. Una buena funci√≥n de dispersi√≥n tiene que determinista, uniforme y con bajo conste computacional.

7 [V] El djb2 diferencia las posiciones de las letras de CASA y SACA mediante desplazamientos a nivel de bits con
la cadena entrante.

Verdadero.
